2.2.1
  1 shell可以理解为软件系统提供给用户操作的命令行界面，可以说它是人机交互的一种方式。
  2 我们可以使用shell和操作系统、uboot等软件进行交互，具体来说就是我们通过shell给软件
    系统输入命令然后回车执行，执行完后又会回到shell命令行可以再次输入命令执行。
  3 可以把一些shell命令写成一个shell脚本程序来完成多个shell命令。
  4 编写shell脚本时使用的语言就是shell语言，又叫脚本语言。shell脚本其实是一类语言而不
    是一个语言（sh bash csh ksh perl python等），在linux常用的脚本语言其实就是bash、sh。
    perl、python这样的高级shell脚本语言，常用在网络管理配置等领域，系统运维人员使用。
    脚本语言一般在嵌入式中应用，主要是用来作配置。(一个复杂的嵌入式程序都是可配置的，配置
    过程就是用脚本语言来实现的)，自然不会使用过于复杂的脚本语言特性，因此只需要针对性的学习即可。
  5 linux下常用的脚本就是bash，我们学习也是以bash为主。
  6 shell脚本的运行机制是解释运行。而像c语言(c++)这些源码是不能直接运行的，而脚本程序编写好后，
    源代码即可直接运行(没有编译链接过程)，所谓解释运行的意思是说当我们执行一个shell程序时，
    shell解析器会逐行的解释shell程序僚友，然后一行一行的执行.(顺序结构)
  7 CPU实际只讹误二进制代码，根本不认识源代码。脚本程序源代码其实也还是二进制代码，cpu也不认识，
    也不能直接执行。只不过脚本程序的编译链接过程还是以脚本程序源代码为单位进行的，而是在脚本运行过程中逐行
    的解释执行时才去完成脚本程序源代码转成二进制的过程(不一定是编译链接，因为这行脚本程序可能早就编译链接好了，
    这里我们只是调用它)的。

2.2.2
  1 shell程序是文本格式的，只要是文本编辑器都可以。但是因为我们的shell是要在linux系统下运行的
    ，所以换行符必须是'\n'，而windows下的换行符是'\r\n'，因此windows中的编辑器写的shell不能在
    linux下运行，所以我们整个课程都是在linux下使用vi编辑器(实际上是vim)进行编写调试的。
  2 shell是解释性语言，不涉及编译，编辑完直接可以运行。
  3 shell程序运行有多种方法，1) ./xx.sh 和运行二进制可执行程序一样。这样运行shell必须具有可执行权限。chmod a+x xx.sh来添加可执行权限
    2) source xx.sh, source是linux的一个命令，这个命令是用来执行脚本程序的，这样运行不需要脚本具有可执行权限。
    3) bash xx.sh bash是一个脚本程序解释器，本质上是一个可执行程序。这样相当于我们执行了bash程序，然后把xx.sh作为argv[1]传给他运行。
  4 shell程序的第一行一般是: #!/bin/sh 这行话的意思就是指定shell程序执行时被哪个解释器解释执行。所以我们这里写上/bin/sh意思是这个
    shell将被当前机器中/bin目录下的sh可执行程序执行。当然我们也可以指定其它的解释器，可以将第一行写为：#!/bin/bash来指定使用bash执行该脚本。
    注意:在ubuntu上默认使用的解释器sh其实不是bash，而是dash。dash是ubuntu中默认的解释器。
  5 脚本中的注释使用#，#开头的行是注释行。如果有多行需要注释，每行面前必须都加#。(#相当于C语言中的//)
  6 shell程序 的正文，由很多行shell语句构成。
  7 shell就是把以前命令行中键入执行的命令写成了程序。shell其实就是为了避免反复的在命令行下手工输入而发明的一种把手工输入步骤记录下来，
    然后通过执行shell脚本程序就能再次复述原来记录的手工输入过程的一种技术。
  8 shell编辑完可以直接运行(不需要编译)

2.2.3
  1 练习1：在当前目录下创建文件a.txt。练习2：当前目录下创建文件夹dir，dir下创建文件b.txt。
  2 变量定义和初始化。shell是弱类型语言(语言中的变量如果有明确的类型则属于强类型语言，变量没有明确类型就是弱类型语言)。
    和C语言不同。在shell编程中定义变量不需要定类型，也没有类型这个概念。
  3 变量定义时可以初始化，使用=进行初始化赋值。在shell中赋值的=两边是不能有空格的。
    注意：shell对语法非常在意，非常严格。很多地方空格都是必须没有或者必须有，而且不能随意有没有空格。
  4 变量定义：变量定义后可以再次给它赋值，新的值会覆盖旧的值。shell中并不刻意区分变量的定义和赋值，反正每个
    变量就是一个符号，这个符号的值就是最后一个给他赋值时的值。
  5 变量的引用：shell中引用一个变量必须使用$符号，$符号就是变量解引用的符号。
    注意：$符号后面跟一个字符串，这个字符串就会被当作变量去解析。如果这个字符串本身没有定义，执行时并不会报错，
    而是把这个变量解析为空。也就是说在shell中没有定义的变量其实就相当于是一个定义并赋值为空的变量。
    注意：变量引用的时候可以$var，也可以${var}，这两种的区别是在某些情况下只能用${var}而不能简单的$var
  6 shell中直接使用双引号可以不加双引号，直接使用。而且有空格也可以，但是缺陷是不能输出转义字符。
  7 shell中也可以使用单引号来表示字符串，也是直接使用的，不能输出转义字符。
  8 单引号中：完全字面替换(不可包含单引号本身)

  转义字符：
  \$ 表示$的字面值，要输出$符号
  \' 表示'的字面值，要输出'符号
  \" 表示“的字面值，要输出"符号
  \\ 表示\的字面值，要输出\符号

2.2.4 选择分支 if
  1 shell中调用linux命令
    ——  直接执行
    ——  反引号括起来执行。有时候我们在shell中调用linux命令是为了得到这个命令的返回值(结果值)，
        这时候就适合用一对反引号(键盘上ESC按键下面的符号和波浪线在一个按键上)来调用执行命令。
  2 shell中的选择分支结构
    shell的if语法结构非常多，只介绍常用的
    典型的if语言格式
    if [表达式]; then
        xxx
        yyy
        zzz
    else
        xxx
        aaa
        bbb
    fi

    if的典型应用
    判断文件是否存在(-f)。注意[]里面前后都有空格，不能省略
    判断目录是否存在(-d)
    判断字符串是否相等("str1" = "str2") 注意用一个等号而不是两个等号
    判断数字是否相等(-eq) 大于(-gt) 小于(-lt) 大于等于(-ge) 小于等于(-le)
    判断字符串是否为空(-z) 注意-z判断时，如果这个变量本身没定义也是成立的(也就是说-z认为没定义不为空)
    if [ -f a.txt ]; then
      echo "yes"
    esle
      echo "no"
      touch a.txt
    fi

    if判断式中使用"-o"表示逻辑或，相当于C语言中在if后面的条件式中用逻辑与、逻辑或来连接2个
    式子，最终的if中是否成立取决于2个式子中的逻辑运算结果。

    逻辑与&&和逻辑或||与简写的if表达式非常多
    [ -z $str ] || echo "fei kong"  如果$str为空，则不执行echo "fei kong",如果$str非空，则执行echo "fei kong"
    [ -z $str ] && echo "kong"  如果$str为空，则执行echo "kong",如果$str非空，则不执行echo "kong"

2.2.5 shell中的循环结构
  1 for循环
    要求：能看懂，能改即可。档要求能够完全不参考写出来，因为毕竟嵌入式产不需要完全重新手写shell，系统管理员(服务器运维人员，
    应用层系统级管理开发才需要完全学习shell编程)

  2 while循环
    和C语言的循环在逻辑上列差别
    要注意很多格式要求，比如：while后面的[]两边都有空格，[]后面有分号，如果do放在一行的话，i++的写法中有两层括号。

  3 echo的创建和追加输入文件
    在shell中可以直接使用echo指令新建一个文件，并且将一些内容传入这个文件中，创建文件并输入内容的关键就是 > .
    还可以使用echo指令配合追加符号>>,向一个已经存在的文件末尾追加输入的内容。

2.2.6 shell中值得关注的知识点
  1 case语句
    shell中的case语句和c语言中的swith case语言作用一样，格式有差异。
    shell中的case语句天生没有break，也不需要break，和c语言中的swith case不同，shell中的case默认就是匹配上哪个就
    执行哪个，不会说执行完了还支执行其它的语句，就好像默认带了括号。
  2 调用shell程序的传参
    shell程序本身也可以在调用时传参给他，在shell程序内部使用传参也是使用一些特定符号来表示的，
    包括：
    $# 表示调用该shell时传参的个数。($#在计数时只考虑真正的参数个数)
    $0 $1 $2... 则依次表示传参的各个参数。

    C语言：./a.out aa bb cc //argc = 4 argv[0] = ./a.out argv[1]是第一个有效参数...
    shell: ./a.sh aa bb cc $# = 3, $0是执行这个shell程序 的解析程序的名字，$1是第一个有效参数的值，$2是第一个有效参数的值。

    注意：shell中的很多语法特性和C语言中是相同的，也有很多是不同的，所以大家学的越多越容易混淆(本质还是因为用的不熟悉，用的少)
    解决方案是：做笔记，做总结，多写代码经常用。
  3 while循环和case语言和传参相结合
    1 shell中的break关键字和c语言中意义相同(都是跳出)，但是用法不同，因为shell中case语句默认不用break的，因此在shell中breadk只用于循环跳出，
      所以当while中内嵌case语句时，case中的break是跳出外层的while循环的，还是用来跳出case语句的。
    2 shell中的$# $1等内置变量的值还是不可变的，而是可以被改变的，被shift指令改变。shift指令有点像左移运算符，把我们给shell程序的传参左移了
      一个移出去了，原来的$2变成了新的$1,原来的$#少了1个。

2.2.7 makefile基础回顾
  1 Makefiler的作用和意义
    1)  工程项目中C文件太多管理不方便，因此用Makefile来做项目管理，方便编译链接过程。
    2)  uboot和linux kernel本质上都是C语言的项目，因此都需要通过Makefile来管理，所以要分析uboot就必须对Makefile有所了解。
  2 目标 依赖和命令
    1)  目标就是我们要去make xxx的那个xxx,就是我们最终要生成的东西。
    2)  依赖是用来生成目录的原材料
    3)  命令就是加工方法，所以make xxx的过程其实就是使用命令将依赖加工成目标的过程。
  3 通配符%和Makefile自动推导(规则)
    1)  %是Makefile中的通配符，代表一个或几个字母。也就是说%.o就代表所有以.o结尾的文件。
    2)  所谓自动推导其实就是Makefile的规则。当Makefile需要某个目标时，他会把这个目标去套规则说明，
        一旦套上了某个规则说明，则Makefile会试图寻找这个规则中的依赖，如果能找到则会执行这个规则用依赖生成目标。
  4 Makefile中定义和使用变量
    1)  Makefile中定义和使用变量，和shell脚本中非常相似，相似是说：都没有变量类型，直接定义使用，引用变量时用$var
  5 伪目标(.PHONY)
    1)  伪目标意思是这个目标本身不代表一个文件，执行这个目标还是为了得到某个文件或东西，只是单纯的为了执行这个目标下面的命令。
    2)  伪目标一般都没有依赖，因为执行伪目标就是为了挂靠目标下面的命令。既然一定要执行命令了那就不必加依赖，因为不加依赖意思就是无条件执行。
    3)  伪目标可以直接写，不影响使用，但是有时候为了明确声明这个目标是伪目标会在伪目标的前面用.PHONY来明确声明它是伪目标。
  6 Makefile的文件名
    1)  Makefile的文件名合法的一般有2个：Makefile或者makefile
  7 Makefile中引用其他Makefile(include指令)
    1)  有时候Makefile总体比较复杂，因此分成好几个Makefile来写。然后在主Makefile中引用其他的，用include指令来引用，引用的效果也是原地展开。
        和c语言中的头文件包含非常相似。

2.2.8
  1 Makefile中的注释用#号，和shell一样。
  2 命令前面的@用来静默执行
    1)  在Makefile的命令行中前面的@表示静默执行。
    2)  Makefile中默认情况下在执行一行命令前会先把这行命令给打印出来，然后再执行这行命令。
    3)  如果你不想看到命令本身，只想看到命令执行的结果就静默执行即可。
  3 Makefile中几种变量赋值运算符
    1)  ?=  如果变量前面没有赋值过则执行这条赋值，如果前面已经赋值过了，则本行会忽略。
        (实验可以看出：所谓的没有赋值过其实就是这个变量没有被定义过)
    2)  +=  用来给一个已经赋值的变量接续赋值，意思就是把这次的值加到原来的值的后面，有点类似于strcat.
        (在shell Makefile等文件中，可以认为所有变量都是字符串，+= 就相当于给字符串strcat接续内容。)
        (注意一个细节，+= 续接的内容和原来的内容之间会自动加一个空格隔开。)
    3)  =   最简单的赋值
    4)  :=  一般也是赋值
        以上这两个大部分情况下效果是一样的，但是有时候不一样。
        用=赋值的变量，在被解析时他的值取决于最后一次赋值时的值，所以你看变量引用的值时不能只往前看，还要往后看。
        用:=来赋值的，则是就地直接解析，只用往前看即可。

    注意：Makefile中并不要求赋值运算符两边一定要有空格或者无空格，这一点比shell 的格式要求要松一些。
  4 Makefile的环境变量
    1)  Makefile中用export导出的就是环境变量。一般情况下要求环境变量名用大写，普通变量名用小写。
    2)  环境变量和普通变量不同，可以这样理解，环境变量类似于整个工程中所有Makefile之间可以共享的全局变量，而普通变量
        只是当前本Makefile中使用的局部变量，所以要注意：定义了一个环境变量会影响到工程中别的Makefile文件，因此要小心。
    3)  Makefile中有一些环境变量可能是Makefile本身自己定义的内部的环境变量或者是当前的执行环境提供的环境变量
        (比如：我们在make执行时给Makefile传参，make CC=arm-linux-gcc,其实就是给当前Makefile传了一个环境变量CC，
        值是arm-linux-gcc，我们在make时给Makefile传的环境变量优先级是最高的，可以覆盖Makefile中的赋值)。
        这就好像C语言中编译器预定义的宏__LINE__FUNCTION__等一样。

2.2.9
  1 Makefile中使用通配符
    1)  *   若干个任意字符
    2)  ?   1个任意字符
    3)  []  将[]中的字符依次去和外面的结合匹配
    4)  {}  (不知有没有 需要验证)

    还有个%，也是通配符，表示任意多个字符，和*很相似，但是%一般只用于规则描述中，又叫做规则通配符。
    关于通配符，Makefile还有一些wildcard等比较复杂的通配符用法。

  2 Makefile的自动变量
    1)  自动变量的含义：预定义的特殊意义的符号，就类似于C语言编译器中预制的那些宏__FILE__一样。
    2)  为什么使用自动变量，在有些情况下文件集合中文件非常多，描述的时候很麻烦，所以我们Makefile就用一些特殊的
        符号来替代符合某种条件的文件集，这就形成了自动变量。

    常见的自动变量：
        $@  规则的目标文件名
        $<  规则的依赖文件名
        $^  依赖的文件集合

        

**为什么有u-boot
1 u-boot主要作用是用来启动操作系统内核。
2 计算机系统的主要部件
  1 计算机系统就是有cpu来做核心进行运行的每户。。典型的计算机系统有：pc机(台式机 笔记本)、
    嵌入式设备(手机、平板电脑、游戏机) 单片机系统(电饭锅、空调)
  2 计算机系统的组成部件非常多，不同的计算机系统组成部件也不同，但是所有的计算机系统运行时需要的
    主要部件都是3个东西：cpu(运算器 + 控制器) + 外部存储器(flash 硬盘) +　内部存储器(DDR SDRAM/SRAM)
3 pc机的启动过程
  1 典型的pc机的部署：BIOS程序部署在pc机主板上(随我们的主板出厂时已经预制了)，操作系统
    部署在硬盘上，内存在掉电时无作用，cpu在掉电时不工作。
  2 启动过程：pc上电后先执行bios程序(实际上pc机的bios就是Norflash，可以直接启动)，bios
    程序负责初始化ddr内存，负责初始化硬盘，然后从硬盘上将os镜像读取到ddr中，然后跳转到
    ddr中去执行os直到启动(os启动后bios就无用了)

4 典型嵌入式linux系统启动过程
  1 嵌入式系统的部署和启动都是参考pc机的，只是设备上有一些差别。
  2 典型嵌入式系统的部署：uboot程序部署在flash上(能作为启动设备的flash)、os部署在flash
    上(嵌入式系统中没有硬盘，用flash代替了硬盘)、内存在掉电时无作用，cpu在掉电时不工作。
  3 启动过程：嵌入式系统上电后先执行u-boot(bootloader)、然后u-boot负责初始化ddr，初始化
    flash，然后将os从flash中读取到ddr中，然后启动os(os启动后u-boot就无用了)

    ——嵌入式系统和pc机的启动过程几乎没有两样，只是bios成了u-boot，硬盘成了flash。

5 android系统启动过程
  1 android系统的启动过程和linux(典型嵌入式linux操作系统)系统几乎一样，几乎一样的意思
    是前面完全一样，只是在内核启动后加载根文件系统后就不同了
  2 可以认为启动分为2个阶段：第一个阶段是u-boot到os启动过程;第二阶段是os启动后到rootfs
    加载到命令行执行。
——小结
  1 u-boot主要作用是用来启动操作系统内核。
  2 u-boot不要负责部署整个计算机系统。
  3 u-boot中还有操作flash等板子上硬盘的驱动。
  4 u-boot还得提供一个命令行界面供人来操作(开机3s内按回车进入命令行)

  fastboot 是u-boot中的一部分

**为什么是u-boot
  开源项目，作者是一个德国人最早发起的项目，由一个人发起，然后由整个网络上所有感兴趣的人
  一起维护发展而来的一个bootloader.
1 u-boot发展历程
  1 一个开源小项目
  2 被更多的人认可使用
  3 被soc厂商默认支持
  ——u-boot经过多年的发展，已经成为了业内bootloader标准。现在大部分的嵌入式设备都会默认使用
    u-boot来作为bootloader。
2 u-boot的版本号
  1 早期的版本号类似于:u-boot 1.1.7.后来的版本号变成了类似于u-boot-2010.06
  2 u-boot的核心部分几乎没变化，越新的版本支持的开发板越多而已，对于一个老版本的芯片来说，
    新旧版本的u-boot并没有差异。
3 u-boot的可移植性的正确理解
  1 u-boot就是universal bootloader(通用的启动代码)，通用的意思就是大各种地方都可以使用。
    所以说u-boot具有可以移植性。
  2 u-boot具有可移植性并不是说u-boot在哪个开发板都可以使用，而是说u-boot具有在源代码级别的
    移植能力，可以针对多个开发板进行移植，移植后就可以在这个开发板上使用了。

——小结
  时势造英雄，任何好的东西都是时代的产物。。
  u-boot的出现是一种必然，如果u-boot也会有另一个bootloader来代替。

**u-boot必须解决哪些问题
1 自身可直接启动
  1 一般的soc都支持多种启动方式，比如：sd卡启动、norflash启动、nandflash启动等。。。
    u-boot要能够开机启动，必须根据具体的soc的启动设计来设计u-boot
  2 u-boot必须进行和硬件相对应的代码级别的更改和移植，才能够保证可以从相应的启动介质启动。
    u-boot中第一阶段的start.S文件中具体处理了这一块。
2 能够引导操作系统内核启动并给内核传参
  1 u-boot的终极目标就是上启动内核
  2 linux内核在设计的时候 ，设计为可以被传参。也就是上说我们可以在u-boot中事先给linux
    内核准备一些启动参数放在内存中特定位置然后传给内核，内核启动后会到这个特定位置去
    取u-boot给他的参数，然后在内核中解析这些参数这些参数将被用来指导linux内核的启动过程。
3 能提供系统部署功能
  1 u-boot必须能够被人借助而完成整个系统(u-boot、kernel、roots等的镜像)，在flash上的烧录工作
  2 裸机教程中刷机(arm裸机第三部分)就是利用u-boot中的fastboot功能将各种镜像烧录到iNand中，然后从iNand中启动
4 能进行soc级和板级硬件管理
  1 u-boot中实现了五部分硬件控制能力(u-boot中初始化了一部分硬件)，因为u-boot为了完成一些任务必须
    让这些硬件工作。比如比如u-boot要实现刷机必须能驱动iNand，比如u-boot要在刷机时lcd上
    显示进度条就必须能驱动lcd，比如u-boot能够通过串口提供操作界面就必须驱动串口。比如u-boot
    要实现内乡功能就必须驱动网卡芯片
  2 soc级(比如串口)就是soc内部外设，板级就是soc外面开发板上面的硬件(比如网卡、iNand)
5 u-boot的生命周期
  1 u-boot的生命周期就是指：u-boot什么时候开始运行，什么时候结束。
  2 u-boot本质上是一个裸机程序(不是操作系统)，一旦u-boot开始soc就会单纯运行运行u-boot(
    意思就是u-boot老鼠街的时候别的程序是不可能同时运行的)。一旦u-boot结束运行则无法再回到u-boot
    (所以所以u-boot启动了内核后u-boot自己本身就死了，想要再次找不到uboot界面只能重启系统。
    重启并不是复活了刚才的u-boot，重启只是u-boot的重启)
  3 u-boot的入口和出口。u-boot的入口就是开机自动启动，u-boot的唯一出口就是启动内核。
    u-boot还能执行很多别的任务(比如烧录系统)，但是其他任务执行完后都可以回到u-boot的命令
    行继续执行u-boot命令，而启动内核命令一旦执行就回不来了。
——总结：u-boot一切都是为了启动内核

**u-boot的工作方式
1 从裸机程序镜像uboot.bin说起
  1 u-boot的本质就是一个裸机程序，和我们裸机全集中定的那些裸机程序xx.bin并没有本质区别。
    如果非说要有区别，那就是：我们写的大部分小于16kb，而u-boot大于16kb(一般u-boot大180k-400k之间)
  2 u-boot本身是一个开源项目，由若干个.c文件和.h文件组成，配置编译之后会生成一个uboot.bin，
    这就是u-boot这个裸机程序的镜像文件。然后这个镜像文件被合理的烧录到启动介质中拿给soc启动。也就是说，u-boot
    大没有运行时，就表现为uboot.bin，一般就躺在启动介质中
  3 u-boot老鼠街时会被加载到内存中，然后一条指令一条指令的拿给cpu去运行。
2 u-boot的全集式shell界面
  1 普通的裸机程序运行起来就直接执行了，执行时效果和代码有关。
  2 有些程序需要和人进行交互，于是乎程序中就实现了一个shell(shell就是提供人机交互的一个界面，回想arm裸机全集第十六部分)
    u-boot实现了一个上shell。
      注意:shell并不是操作系统，和操作系统一点关系都没有。linux中打开一个终端后就得到了
      一个shell，可以输入命令回车执行。u-boot中的shell工作方式和linux中的终端shell非常像(
      其实几乎是一样的，只是命令集不一样)
3 u-boot使用的2个关键点：命令和环境变量
  1 u-boot启动后大部分时间和工作都是在shell下完成的(比如u-boot要部署系统要在shell下输命令、
    要设置环境变量也得在命令行下，要启动内核也要在命令行底下敲命令)
  2 命令就是就是u-boot的shell中可以识别的各种命令。u-boot中有几十个命令，其中有一些常用，另一些
    不常用(也可以自己添加u-boot命令)
  3 环境变量和操作系统的环境变量工作的原理和方式几乎完全相同。u-boot在设计时借助了操作系统的设计理念(
    命令行工作方式借鉴了linux终端命令行，环境变量借鉴了操作系统的环境变量，u-boot的驱动管理几乎完全
    照抄了linux驱动框架。 )
  4 环境变量可以被认为是系统的全局变量，环境变量名都是系统内置的(系统自带的环境变量.比如：PATH。也可以自己添加)
    系统或者我们自己和程序在运行时可以通过读取环境变量来指导程序的运行。这样设计的好处就是灵活，比如我们
    要让一个程序更改运行方法，不用去重新修改程序代码再重新编译运行，而只要修改相应的环境变量就可以了。
  5 环境变量就是运行时的配置属性
——总结：
  1 及时复习arm裸机和现在讲到的相关的知识点，在复习中巩固arm裸机中学到的。
  2 及时对照原来arm裸机中讲到的相关部分，可以帮助理解当前讲到的差误点。
  3 结合arm裸机中和现在讲的，对比分析思考，会得到更多。

**u-boot常用命令
1 类似linux终端的缓冲命令行
  1 行缓冲的意思是：当我们向终端命令行输入命令的时候，这些命令没有立即被系统识别，而是被缓冲到
    一个缓冲区(也就是系统认为我们还没有输入完成，)当我们按下回车键后，系统就认为我们输入完了，然后将缓冲区
    中所有的输入当作命令行来分析执行。
  2 linux终端设计有3种缓冲机制：无缓冲、行缓冲、全缓冲
2 有些命令有简化的别名
  1 例如printenv 可以简化为print 、setenv可以简化为set
3 有些命令会带参数(注意格式是固定的)
  1 u-boot的每个命令都有事先规定好的各种格式，有些命令就是不带参数的，比如printenv/print命令;
    有些命令带可选的参数(可以带也可以不带，当然带不带参数的执行结果是不同的);有些命令带必须
    的参数(比如说：setenv/set命令)
4 命令中的特殊符号(比如单引号)
  1 u-boot的有些命令带的参数非常长，为了告诉u-boot这个非常长而且中间有好多个空格的东西给他的一整个参数，所以用
    单引号将这个很长且中间有空格隔开的参数引起来。
  2 别的符号也许也有，而且有特定的意义，当碰到u-boot的命令行有特殊符号时要注意的不是弄错了，而是可能有特殊的含义。
5 有些命令是一个命令族
  1 命令族意思就是好多个命令开头都是用同一个命令关键字，从但是后面的参数不一样，这些命令的功能和作用也不同。这就叫一个命令族。
  2 同一个命令族贵所有的命令都是有极大的关联的，比如movi开头的命令族都和moviNand(三星公司添加)(EMMC、iNand)操作有关。
6 u-boot常用命令
——printenv/print
  1 print命令不用带参数，作用是打印出系统中所有的环境变量。
  2 环境变量就好像程序的全局变量一样，程序中八哥地方都可以根据需要去调用或者更改环境变量(
  一般都是调用)，环境变量和全局变量不同之处在于：全局变量的生命周期是在程序的一次运行当中，
  开始运行时诞生程序结束时死亡，下次运行程序时从头开始，但是环境变量被存储在flash的另一块专门区域
  (flash上有一个环境变量分区)，一旦我们在程序中保存也该环境变量，那么下次开机时该环境变量的值将
  维持上一次更改保存后的值
——setenv/set
  1 set name value
——saveenv/save
  saveenv/save 命令不带参数，直接执行，作用是将内存中的环境变量的值同步保存到flash中环境
  变量的分区。注意：环境变量的保存是整体的覆盖保存，也就是说内存中的所有环境变量都会整体的将
  flash中环境变量分区中原来的内容整体覆盖。
  总结：彻底更改一个环境变量的值，需要2步：1 set命令来更改内存中的环境变量。2 用save命令
  将其同步到flash中环境变量分区。注意：如果不save的话，当前的更改只存在于内存中，当前的
  u-boot运行中起效，但是下一次重启以后仍然是以前的值，设置无效。
——ping ipaddr

u-boot
1 u-boot的主要作用是为了启动内核，那么在启动内核的过程中，首先要能够配置内核，而我们实验用的
  内核镜像是在主机上面的(也就是在windows 或者是在ubuntu上)。它首先要做的是能够把内核镜像从主机上面
  下载到开发板。

下载：fastboot和tftp的方式
fastboot的方式是通过usb线进行数据传输
tftp：是通过有线网络传输的。


2.1.9 常用命令
1 movi
  开发板如果用sd卡/EMMC /iNAND等作为flash，则在uboot中操作flash的指令movi（或mmc）
2 nand

3 mm mw md
  md (mememry display)

4 bootm go

环境变量：
5 bootdelay

6 ipaddr severip gateway netmask ethaddr

7 bootcmd
  set bootcmd 'movi read kernel 0x30008000; bootm 0x30008000'

8 bootargs



  movi read {u-boot | kernel} {addr}
  解释：这个命令使用了一种通用型的描述方法来描述：movi 和read 外面没有任何标记，说明每一次使用这个
  指令都是必须的。一对大括号{}括起来的部分必选1个，大括号中的竖线表示多选一，中括号[]表示可选参数（可以有也可以没有）

# C语言指针

## 基本概念
把一个变量所在的内存单元的地址保存在另外一个内存单元中，保存地址的这个内存单元称为指针。

## 定义
```c
int i;
int *pi = &i;   //定义一个指向int型指针变量pi,并用i的地址来初始化pi。
char c;
char *pc = &c;    //定义一个指向char型的指针变量pc,并用 c的地址来初始化pc。
```
pi 和 pc虽然是不同类型的指针变量，但他们所占的内存单元都是4个字节，因为要保存32位的虚拟
地址，在64位的系统中，指针变都占8个字节。而在访问时，pi能访问地址后的8个字节，pc只能访问
地址后的4个字节。

` & ` 是取地址运算符(Address Operator) &i 表示取变量i的地址。   
` * ` 是指针间接寻址运算符(Indirection Operator) ` *pi ` 表示取指针pi所指向的变量的值     

> 指针之间可以相互赋值，也可以用一个指针初始化另一个指针。用一个指针给另一个指针赋值时，
一定要注意，两个指针必须为同一类型。

```c
int *ptri, *ptrc;
ptri = pi;    //把指针变量pi所保存的地址赋值给指针变量ptri。用pi初始化ptri

ptrc = (int \*)pc;    //经过强制类型转换以后，char型的指针变量pc可以赋值给int型的指针变量ptrc
```

> 不确定类型的指针为野指针(Unbound Pointer)，为避免出现野指针，在定义指针变量时就应该给
它明确的初值或者把它初始化为NULL(空指针)。

> 操作系统不会把八哥数据保存在地址0及其附近，也不会把地址0~0xfff(4个字节)页面映射到物理内存，所以
任何对地址0的访问都会立刻导致段错误。例如` *p = 0 `这种写法是错误的。这样相比野指针来说，
更容易发现错误。

** `void *` ** 指针 ANSI 在将C语言标准化时引入了` void * `类型，` void * `类型与其它
类型的指针之间可以隐式转换，而不必用类型转换运算符。
```c
void func(void *pv)
{
//  * pv = 'A';   //这种写法是错误的 void * 类型不通直接dereference,而必须先转换为其它类型的指针再做dereference.
  char * pchar = pv;
  * pchar = 'A';
}

//为什么要用typedef定义类型名，而不用#define定义类型名

typedef int* pint_t;
#define pint_t int*;

int main(void)
{
  char c;
  func(&c);
  printf("%c\n", c);
}
```

## 指针类型的参数和返回值
```c
int* swap(int *px, int *py)
{
    int temp;
    temp = \*px;
    \*px = \*py;
    \*py = \*temp;
    return px;    //相当于建立了一个临时变量，并用px初始化。即：int \*tmp = px
}

int main(void)
{
    int i = 10, j = 20;
    int \*p = swap( &i, &j);
    printf("now i=%d j=%d \*p=%d\n", i, j, \*p);
    return 0;
}
```


## 指针操作
* 赋值
* 求值或取值
* 取指针地址
* 将一个整数加给指针
* 增加指针的值
* 从指针中减去一个整数
* 减小指针的值
* 求差值
* 比较

## 声明数组参数
```c
//原型声明，4种方法可以任意选一种，因为原型声明时，可以省略名称。
//其中的参数叫形参，
//一般情况下可以省略，不过有时为了程序的可读性，这四种我们需要灵活的选择。
int sum(int *ar, int n);    
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);

//函数定义,以下两种定义方式是等价的。
//处理数组的函数实际上是使用指针做为参数的，但是在编写处理数组的函数时，数组符号和指针符号都是可以选用的，习惯之下，如果这个参数指向一个元素，通常写成指针的形式，如果这个参数指向一串元素中的首元素，则经常写成数组的形式。
int sum( int *ar, int n)
{
    //code
}
int sum(int ar[], int n)
{
    //code
}
```

## 指针与结构体

```c
struct unit{
    char c;
    int num;
};
struct unit u;  //定义结构体u
struct unit *p = &u;  //定义结构体指针p
```
可以通过指针p访问结构体成员,`(*p).c` 和 `(*p).num`为了书写方便，也可以使用 `->`运算符。
即可以写成：`p -> c`或者是`p -> num`。

## 指向指针的指针与指针数组

指针可以指向基本类型，也可以指向复合类型，一个指针指向另一个指针，称为指向指针的指针。

```c
int i;
int *pi = &i;
int **ppi = &pi; //*ppi取pi的值，**ppi取i的值。

//甚至你可以这样定义，但是很少用到
int ***p;

//数组中每个元素可以是基本类型，也可以是复合类型，因此也可以是指针类型，这种每个元素都是指针的数组称为 **指针数组** 。例如：
int *a[10];   //定义一个数组a[]，每个元素都是`int *`类型指针

//区分
int *a[10]; 和 int **pa;   //a是由10个`int *`元素组成的数组，`int **pa = &a[0];`从表达式中也可以看出，a[0]里面存的是`int *`型元素
int a[10]; 和 int *pa;   //a是由10个`int`元素组成的数组，`int *pa = &a[0];`从表达式吓可以看出，a[0]里面存的是`int`型元素。
```

## 指向数组的的指针与多维数组

`int (*a)[10]; //指向数组的指针`   
```c
//上面的语句可以改写成
typedef int t[10];    //t代表由10个`int`组成的数组类型
t *a;   //a则是指向这种类型的指针

//怎么使用指向数组的指针
int a[10];
int (* pa)[10] = &a;
```
&a[0] 表示数组a的首元素的首地址，而&a表示数组a的首地址，这两个地址的数值相同，但这两个表达式的类型是两种不同的指针类型，前者的类型是`int *`, 而后者的类型是`int (*)[10]` 。`*pa`就表示pa所指向的数组a，所以取数组a[0]元素可以用表达式`(*pa)[0]`

```c
int a[5][10];
int (* pa)[10] = &a[0];
```

区分：
```c
int a[5][10];和 int (* pa)[10];
int a[10];和int *pa;
```

## 函数类型和函数指针类型  
在C语言中，函数也是一种类型，可以定义指向函数的指针。指针变量的内存单元存放一个地址值，而函数指针存放的就是函数的入口地址（位于.text段）
```c
void say_hello(const char *str)
{
    printf("hello %s\n", str);
}

int main(void)
{
    void (*f)(const char * ) = say_hello;
    f("guys");
    return 0;
}
```
say_hello是一种函数类型，函数和数组类型类似，做右值时自动转换成函数的指针类型，所以可以直接赋给地，当然也可以写成 `void (*f)(const char *) = &say_hello;`,把函数`say_hello`先取地址再赋给`f`，就不需要自动类型转换了。

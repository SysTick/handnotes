# C语言指针

## 基本概念
把一个变量所在的内存单元的地址保存在另外一个内存单元中，保存地址的这个内存单元称为指针。

## 定义
```c
int i;
int *pi = &i;   //定义一个指向int型指针变量pi,并用i的地址来初始化pi。
char c;
char *pc = &c;    //定义一个指向char型的指针变量pc,并用 c的地址来初始化pc。
```
pi 和 pc虽然是不同类型的指针变量，但他们所占的内存单元都是4个字节，因为要保存32位的虚拟
地址，在64位的系统中，指针变都占8个字节。而在访问时，pi能访问地址后的8个字节，pc只能访问
地址后的4个字节。

` & ` 是取地址运算符(Address Operator) &i 表示取变量i的地址。   
` * ` 是指针间接 寻址运算符(Indirection Operator) ` *pi ` 表示取指针pi所指向的变量的值     

> 指针之间可以相互赋值，也可以用一个指针初始化另一个指针。用一个指针给另一个指针赋值时，
一定要注意，两个指针必须为同一类型。

```c
int *ptri, *ptrc;
ptri = pi;    //把指针变量pi所保存的地址赋值给指针变量ptri。

ptrc = (int \*)pc;    //经过强制类型转换以后，char型的指针变量pc可以赋值给int型的指针变量ptrc
```

> 不确定类型的指针为野指针(Unbound Pointer)，为避免出现野指针，在定义指针变量时就应该给
它明确的初值或者把它初始化为NULL(空指针)。

> 操作系统不会把八哥数据保存在地址0及其附近，也不会把地址0~0xfff(4个字节)页面映射到物理内存，所以
任何对地址0的访问都会立刻导致段错误。例如` *p = 0 `这种写法是错误的。这样相比野指针来说，
更容易发现错误。

** `void *` ** 指针 ANSI 在将C语言标准化时引入了` void * `类型，` void * `类型与其它
类型的指针之间可以隐式转换，而不必用类型转换运算符。
```c
void func(void *pv)
{
//  * pv = 'A';   //这种写法是错误的
  char * pchar = pv;
  * pchar = 'A';
}

int main(void)
{
  char c;
  func(&c);
  printf("%c\n", c);
}
```

## 指针类型的参数和返回值
```c
int* swap(int *px, int *py)
{
    int temp;
    temp = \*px;
    \*px = \*py;
    \*py = \*temp;
    return px;    //相当于建立了一个临时变量，并用px初始化。即：int \*tmp = px
}

int main(void)
{
    int i = 10, j = 20;
    int \*p = swap( &i, &j);
    printf("now i=%d j=%d \*p=%d\n", i, j, \*p);
    return 0;
}
```

## 指针和数组
```c
int a[10];
int *pa = &a[0];  //指针pa指向a[0]的地址。
pa++;   //pa++表示让pa指向数组a[]的下一个元素，即a[1];因为pa为`int*`型，所以pa++使pa的地址加4。
```

下面和几种指针和数组的表达方式要注意区分：   
`pa + 2  和 a[2]`   
`* (pa + 2) 和 pa[2]`    //解释：数组名做右值时，自动转换为指向首元素的指针，所以a[2]和pa[2]本质上是一样的，都是通过指针间接寻址访问元素。   
所以：   
`int *pa = &a[0];`  //也合法，但是一般不这么写，推荐写成`int *pa = a;`

## 指针操作
* 赋值
* 求值或取值
* 取指针地址
* 将一个整数加给指针
* 增加指针的值
* 从指针中减去一个整数
* 减小指针的值
* 求差值
* 比较

## 声明数组参数
```c
//原型声明，4种方法可以任意选一种，因为原型声明时，可以省略名称。
//其中的参数叫形参，
//一般情况下可以省略，不过有时为了程序的可读性，这四种我们需要灵活的选择。
int sum(int *ar, int n);    
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);

//函数定义,以下两种定义方式是等价的。
//处理数组的函数实际上是使用指针做为参数的，但是在编写处理数组的函数时，数组符号和指针符号都是可以选用的，习惯之下，如果这个参数指向一个元素，通常写成指针的形式，如果这个参数指向一串元素中的首元素，则经常写成数组的形式。
int sum( int *ar, int n)
{
    //code
}
int sum(int ar[], int n)
{
    //code
}
```

## 指针与`const`限定符
```c
//下面这两种写法一样
//a是一个指向const int型的指针，a所指向的内存单元不可改写，所以(*a)++是不允许的，但a是可以改写的，所以a++是允许的。
const int *a;  
int const *a;  

//a是一个指向int型的const指针，*a是可以改写的，但a不允许改写。
int *const a;  

//a是一个指向const int 型的const指针，因此，*a和a都不允许改写。
int const * const a;

//指向非const变量的指针或者非const变量的地址可以传给指向const变量的指针，编译器可以做隐式类型转换。
char c = 'a';
const char *pc = &c;

//指向const变量的指针或者const变量的地址不可以传给指向非const变量的指针，以免透过后者意外改写了前者所指向的内存单元，例如对下面的代码编译器会报警告
const char c = 'c';
char *pc = &c;

//字符串字面值类似于数组名，做右值使用时自动转换成指向首元素的指针。
const char *p = "abcd";   //如果要定义一个指针指向字符串字面值，这个指针应该是const char *型。
const char strl[5] = "abcd";
char str2[5] = "abcd";
printf(p);    //printf函数原型为`int printf(const char *format,...)`
printf(str1);
printf(str2);
printf("abcd");
```

## 指针与结构体

```c
struct unit{
    char c;
    int num;
};
struct unit u;
struct unit *p = &u;
```
可以通过指针p访问结构体成员,`(*p).c` 和 `(*p).num`为了书写方便，也可以使用 `->`运算符。
即可以写成：`p -> c`或者是`p -> num`。

## 指向指针的指针与指针数组

指针可以指向基本类型，也可以指向复合类型，一个指针指向另一个指针，称为指向指针的指针。

```c
int i;
int *pi = &i;
int **ppi = &pi; //*ppi取pi的值，**ppi取i的值。

//甚至你可以这样定义，但是很少用到
int ***p;

//数组中每个元素可以是基本类型，也可以是复合类型，因此也可以是指针类型，这种每个元素都是指针的数组称为 **指针数组** 。例如：
int *a[10];   //定义一个数组a[]，每个元素都是`int *`类型指针

//区分
int *a[10]; 和 int **pa;   //a是由10个`int *`元素组成的数组，`int **pa = &a[0];`从表达式中也可以看出，a[0]里面存的是`int *`型元素
int a[10]; 和 int *pa;   //a是由10个`int`元素组成的数组，`int *pa = &a[0];`从表达式吓可以看出，a[0]里面存的是`int`型元素。
```

## 指向数组的的指针与多维数组

`int (*a)[10]; //指向数组的指针`   
```c
//上面的语句可以改写成
typedef int t[10];    //t代表由10个`int`组成的数组类型
t *a;   //a则是指向这种类型的指针

//怎么使用指向数组的指针
int a[10];
int (* pa)[10] = &a;
```
&a[0] 表示数组a的首元素的首地址，而&a表示数组a的首地址，这两个地址的数值相同，但这两个表达式的类型是两种不同的指针类型，前者的类型是`int *`, 而后者的类型是`int (*)[10]` 。`*pa`就表示pa所指向的数组a，所以取数组a[0]元素可以用表达式`(*pa)[0]`

```c
int a[5][10];
int (* pa)[10] = &a[0];
```

区分：
```c
int a[5][10];和 int (* pa)[10];
int a[10];和int *pa;
```

## 函数类型和函数指针类型  
在C语言中，函数也是一种类型，可以定义指向函数的指针。指针变量的内存单元存放一个地址值，而函数指针存放的就是函数的入口地址（位于.text段）
